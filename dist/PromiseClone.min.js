!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).PromiseClone=e.PromiseClone||{})}(this,(function(e){"use strict";const t=e=>"function"==typeof e,n=new RegExp(String.raw`function .*\(\) \{ \[native code\] \}`),o=void 0!==globalThis?globalThis:void 0!==self?self:void 0!==window?window:void 0!==global?global:{},r=(()=>{const{process:e,MutationObserver:r,setImmediate:s,setTimeout:i}=o,{nextTick:l}=e||{};if(l)return function(){l.call(e)};if(t(c=r)&&n.test(c.toString())){let e=1;const t=[],n=document.createTextNode(e+"");function o(){n.data=e=1===e?0:1}return new r((function(){t.shift()(),t.length&&o()})).observe(n,{characterData:!0}),function(e){!t.length&&o(),t.push(e)}}return t(s)?function(e){s(e)}:t(i)?function(e,t,...n){i(e,t,...n)}:void 0;var c})();class s extends Error{name="AggregateCloneError";constructor(e){super(),this.error=this.message=e}}const i=(e,n,o,r)=>{if(Object.is(e,n))r(new ReferenceError("chaining cycle detected in PromiseClone"));else if(e===Object(e))try{const{then:s}=e;if(t(s))try{s.call(e,(e=>i(e,n,o,r)),r)}catch(e){r(e)}else o(e)}catch(e){r(e)}else o(e)},{PENDING:l,REJECTED:c,FULFILLED:a}={PENDING:"pending",FULFILLED:"fullfilled",REJECTED:"rejected"};function u(e){if(!new.target)throw new TypeError("Fail to construct 'PromiseClone': Please use the 'new ' operator, this native object constructor cannot be called as a function");this.state=l,this.result=void 0;const n=[],o=[],s=Object.getPrototypeOf(this);s.then||(s.then=function(e,s){!t(e)&&(e=e=>e),!t(s)&&(s=e=>{throw e});const f=new u(((t,u)=>{const{state:h}=this,d=()=>{try{let n=e(this.result);i(n,f,t,u)}catch(e){u(e)}},g=()=>{try{let e=s(this.result);i(e,f,t,u)}catch(e){u(e)}};h===a?r(d):h===c?r(g):h===l&&(n.push((()=>r(d))),o.push((()=>r(g))))}));return f});const f=e=>{i(e,this,(e=>{this.state===l&&(this.state=a,this.result=e,n.forEach((e=>e())))}),h)},h=e=>{this.state===l&&(this.state=c,this.result=e,o.forEach((e=>e())))};try{e(f,h)}catch(e){h(e)}}Object.defineProperty(u,Symbol.toStringTag,{value:"PromiseClone"}),Promise.resolve=function(e){return new u(((t,n)=>{t(e)}))},u.prototype.catch=function(e){return this.then(null,e)},u.prototype.finally=function(e){return this.then(e,e)},u.reject=function(e){return new u(((t,n)=>{n(e)}))},u.all=function(e){return new u(((t,n)=>{try{e=[...e]}catch(e){n(e)}const{length:o}=e,r=[];if(0===o)return void t(r);let s=0;const i=(e,n)=>{r[e]=n,++s>=o&&t(r)};for(let t=0;t<o;t++){let o=e[t];isPromiseClone(o)?o.then((e=>{i(t,e)}),(e=>{n(e)})):i(t,o)}}))},u.race=function(e){return new u(((t,n)=>{try{e=[...e]}catch(e){n(e)}let{length:o}=e;for(let r=0;r<o;r++){let o=e[r];isPromiseClone(o)?o.then(t,n):u.resolve(o).then(t)}}))},u.allSettled=function(e){return new u(((t,n)=>{try{e=[...e]}catch(e){n(e)}let{length:o}=e,r=[];if(0===o)return void t(r);let s=0;const i=(e,n,i)=>{const l="fulfilled"===i?"value":"reason";r[e]={status:i,[l]:n},++s>=o&&t(r)};for(let t=0;t<o;t++){const n=e[t];isPromiseClone(n)?n.then((e=>i(t,e,"fulfilled")),(e=>i(t,e,"rejected"))):i(t,n,"fulfilled")}}))},u.any=function(e){return new u(((t,n)=>{try{e=[...e]}catch(e){n(e)}let o=0;const{length:r}=e,i=e=>{++o>=r&&n(new s("No Promise in PromiseClone.any was resolved"))};if(0!==r)for(let n=0;n<r;n++){const o=e[n];isPromiseClone(o)?o.then(t,i):u.resolve(o).then(t)}else i()}))},e.default=u,Object.defineProperty(e,"__esModule",{value:!0})}));
